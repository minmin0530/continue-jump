<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>get started with three.js</title>
</head>
<body>
 
<script src="three.min.js"></script>
<script src="helvetiker_bold.typeface.js"></script>
<script>
var PLAYER_SIZE = 5;
var GRAVITY = 0.05;
var CUBE_SIZE = 10;
var CUBE_NUM = 9;
var Z_NUM = 5;
var JUMP_SPEED = 1.53;
var jump_speed = 0;
var x_speed = 0;
var z_speed = 0;
var angle = 0;
var rotation_flag = false;
var player;
var player_pos;
var mesh = new Array(Z_NUM);
var pos = new Array(Z_NUM);
var textGeometry = new Array(11);
var textNumber = new Array(11);

var geometry2 = new Array(CUBE_NUM * CUBE_NUM * Z_NUM);
var geometry22 = new Array(CUBE_NUM * CUBE_NUM * Z_NUM);
var lines = new Array(CUBE_NUM * CUBE_NUM * Z_NUM);

var keyArray = new Array(6);
var keyArrayUp = new Array(6);

var key_repeat_x_plus = false;
var key_repeat_x_minus = false;
var key_repeat_z_plus = false;
var key_repeat_z_minus = false;

document.addEventListener("keydown", function(e) {
    switch(e.keyCode) {
    case 37: keyArray[0] = true; break;
    case 38: keyArray[1] = true; break;
    case 39: keyArray[2] = true; break;
    case 40: keyArray[3] = true; break;
    case 88: keyArray[4] = true; break;
    case 90: keyArray[5] = true; break;
    }
}, false);

document.addEventListener("keyup", function(e) {
    switch(e.keyCode) {
    case 37: keyArrayUp[0] = true; break;
    case 38: keyArrayUp[1] = true; break;
    case 39: keyArrayUp[2] = true; break;
    case 40: keyArrayUp[3] = true; break;
    case 88: keyArrayUP[4] = true; break;
    case 90: keyArrayUP[5] = true; break;
    }
}, false);

function x_left(x, y, z)
{
for (var i = -1; i <2; ++i) {
for (var j = -1; j <2; ++j) {
if (
player_pos.x > mesh[z+j][y+i][x-1].position.x - (CUBE_SIZE + PLAYER_SIZE) / 2 &&
player_pos.x < mesh[z+j][y+i][x-1].position.x + (CUBE_SIZE + PLAYER_SIZE) / 2 &&
player_pos.y < mesh[z+j][y+i][x-1].position.y + (CUBE_SIZE + PLAYER_SIZE) / 2 &&
player_pos.y > mesh[z+j][y+i][x-1].position.y - (CUBE_SIZE + PLAYER_SIZE) / 2 &&
player_pos.z > mesh[z+j][y+i][x-1].position.z - (CUBE_SIZE + PLAYER_SIZE) / 2 &&
player_pos.z < mesh[z+j][y+i][x-1].position.z + (CUBE_SIZE + PLAYER_SIZE) / 2
) {
	if (player_pos.x < mesh[z+j][y+i][x-1].position.x  + (CUBE_SIZE + PLAYER_SIZE) / 2) {
		player_pos.x = mesh[z+j][y+i][x-1].position.x  + (CUBE_SIZE + PLAYER_SIZE) / 2;
		x_speed = 0;
	}
}
}
}
}

function x_right(x, y, z)
{
for (var i = -1; i <2; ++i) {
for (var j = -1; j <2; ++j) {
if (
player_pos.x > mesh[z+j][y+i][x+1].position.x - (CUBE_SIZE + PLAYER_SIZE) / 2 &&
player_pos.x < mesh[z+j][y+i][x+1].position.x + (CUBE_SIZE + PLAYER_SIZE) / 2 &&
player_pos.y < mesh[z+j][y+i][x+1].position.y + (CUBE_SIZE + PLAYER_SIZE) / 2 &&
player_pos.y > mesh[z+j][y+i][x+1].position.y - (CUBE_SIZE + PLAYER_SIZE) / 2 &&
player_pos.z > mesh[z+j][y+i][x+1].position.z - (CUBE_SIZE + PLAYER_SIZE) / 2 &&
player_pos.z < mesh[z+j][y+i][x+1].position.z + (CUBE_SIZE + PLAYER_SIZE) / 2
) {
	if (player_pos.x > mesh[z+j][y+i][x+1].position.x  - (CUBE_SIZE + PLAYER_SIZE) / 2) {
		player_pos.x = mesh[z+j][y+i][x+1].position.x  - (CUBE_SIZE + PLAYER_SIZE) / 2;
		x_speed = 0;
	}
}
}
}
}

function y_top(x, y, z)
{
for (var i = -1; i <2; ++i) {
for (var j = -1; j <2; ++j) {
if (
player_pos.x > mesh[z+j][y+1][x+i].position.x - (CUBE_SIZE + PLAYER_SIZE) / 2 &&
player_pos.x < mesh[z+j][y+1][x+i].position.x + (CUBE_SIZE + PLAYER_SIZE) / 2 &&
player_pos.y < mesh[z+j][y+1][x+i].position.y + (CUBE_SIZE + PLAYER_SIZE) / 2 &&
player_pos.y > mesh[z+j][y+1][x+i].position.y - (CUBE_SIZE + PLAYER_SIZE) / 2 &&
player_pos.z > mesh[z+j][y+1][x+i].position.z - (CUBE_SIZE + PLAYER_SIZE) / 2 &&
player_pos.z < mesh[z+j][y+1][x+i].position.z + (CUBE_SIZE + PLAYER_SIZE) / 2
) {
	if (player_pos.y > mesh[z+j][y+1][x+i].position.y  - (CUBE_SIZE + PLAYER_SIZE) / 2) {
		player_pos.y = mesh[z+j][y+1][x+i].position.y  - (CUBE_SIZE + PLAYER_SIZE) / 2;
		jump_speed = 0;
	}
}
}
}
}


function z_front(x, y, z)
{
for (var i = -1; i <2; ++i) {
for (var j = -1; j <2; ++j) {
if (
player_pos.x > mesh[z][y+i][x+j].position.x - (CUBE_SIZE + PLAYER_SIZE) / 2 &&
player_pos.x < mesh[z][y+i][x+j].position.x + (CUBE_SIZE + PLAYER_SIZE) / 2 &&
player_pos.y < mesh[z][y+i][x+j].position.y + (CUBE_SIZE + PLAYER_SIZE) / 2 &&
player_pos.y > mesh[z][y+i][x+j].position.y - (CUBE_SIZE + PLAYER_SIZE) / 2 &&
player_pos.z > mesh[z][y+i][x+j].position.z - (CUBE_SIZE + PLAYER_SIZE) / 2 &&
player_pos.z < mesh[z][y+i][x+j].position.z + (CUBE_SIZE + PLAYER_SIZE) / 2
) {
	if (player_pos.z < mesh[z][y+i][x+j].position.z + (CUBE_SIZE + PLAYER_SIZE) / 2) {
		player_pos.z = mesh[z][y+i][x+j].position.z  + (CUBE_SIZE + PLAYER_SIZE) / 2;
		z_speed = 0;
	}
}
}
}
}

function z_back(x, y, z)
{
for (var i = -1; i <2; ++i) {
for (var j = -1; j <2; ++j) {
if (
player_pos.x > mesh[z+1][y+i][x+j].position.x - (CUBE_SIZE + PLAYER_SIZE) / 2 &&
player_pos.x < mesh[z+1][y+i][x+j].position.x + (CUBE_SIZE + PLAYER_SIZE) / 2 &&
player_pos.y < mesh[z+1][y+i][x+j].position.y + (CUBE_SIZE + PLAYER_SIZE) / 2 &&
player_pos.y > mesh[z+1][y+i][x+j].position.y - (CUBE_SIZE + PLAYER_SIZE) / 2 &&
player_pos.z > mesh[z+1][y+i][x+j].position.z - (CUBE_SIZE + PLAYER_SIZE) / 2 &&
player_pos.z < mesh[z+1][y+i][x+j].position.z + (CUBE_SIZE + PLAYER_SIZE) / 2
) {
	if (player_pos.z > mesh[z+1][y+i][x+j].position.z - (CUBE_SIZE + PLAYER_SIZE) / 2) {
		player_pos.z = mesh[z+1][y+i][x+j].position.z  - (CUBE_SIZE + PLAYER_SIZE) / 2;
		z_speed = 0;
	}
}
}
}
}

var main = function () {
  var scene = new THREE.Scene();								//シーン（世界、舞台）
 
  var width  = 1024;												//画面の幅
  var height = 512 + 256;												//画面の高さ
  var fov    = 90;												//画角
  var aspect = width / height;									//画面の縦横比
  var near   = 1;												//カメラに映る最短距離
  var far    = 10000;											//カメラに映る最長距離
  var camera = new THREE.PerspectiveCamera( fov, aspect, near, far );//カメラを作成：画角、縦横比、近、遠
  camera.position.set(0, 0, 75);
  camera.lookAt( {x:0, y:0, z:0 } );
 
  var renderer = new THREE.WebGLRenderer();						//レンダラー：３Dをhtmlに描き込むもの
  renderer.setSize( width, height );								//描き込む画面のサイズ
  renderer.setClearColorHex(0x888888, 1.0);
  document.body.appendChild( renderer.domElement );				//htmlに登録
 
  var directionalLight = new THREE.DirectionalLight( 0xffffff );		//ライト：白色ライト
  directionalLight.position.set( 0, 0.7, 0.7 );						//ライト位置：X：０、　Y：0.7、　Z：0.7
  scene.add( directionalLight );									//シーンに登録（カメラに見える世界に登録）


  player_pos = new THREE.Vector3(0, 0, 0);
  var geometry_player = new THREE.CubeGeometry(PLAYER_SIZE, PLAYER_SIZE, PLAYER_SIZE);
  var material_player = new THREE.MeshPhongMaterial( { color: 0x00ff00, transparent:true, blending:THREE.NormalBlending, opacity:0.5 } );//緑
  player = new THREE.Mesh( geometry_player, material_player );				//メッシュ：形と色を１つにまとめる。
  player.position.set(player_pos.x,player_pos.y,player_pos.z);
  scene.add(	player);



for (var z = 0; z < Z_NUM; ++z) {       mesh[z]     = new Array(CUBE_NUM);   pos[z]     = new Array(CUBE_NUM);
for (var y = 0; y < CUBE_NUM; ++y){ mesh[z][y] = new Array(CUBE_NUM);   pos[z][y] = new Array(CUBE_NUM);
for (var x = 0; x < CUBE_NUM; ++x) {
if (x == 0 || x == CUBE_NUM - 1|| y == 0 || y == CUBE_NUM -1 ||
x % 2 ==  0 &&  y % 2 == 0 && z % 2 == 1// ||
//x % 2 == 1 && y % 2 == 1 && z % 2 == 0
) {
  var index = z * 10 * 10 + y * 10 + x;
  var HALF =CUBE_NUM * CUBE_SIZE / 2 - CUBE_SIZE / 2;
  var HALF_Z = Z_NUM * CUBE_SIZE / 2 - CUBE_SIZE / 2;
  pos[z][y][x] = new THREE.Vector3(x * CUBE_SIZE - HALF, y * CUBE_SIZE - HALF, z * CUBE_SIZE - HALF_Z);
  var geometry = new THREE.CubeGeometry(CUBE_SIZE, CUBE_SIZE, CUBE_SIZE);
  var material;
if (x == 5 && y == 1 && z == 0) {
material = new THREE.MeshPhongMaterial( { color: 0x0000ff, transparent:true, blending:THREE.NormalBlending, opacity:0.5 } );	//青
} else {
material = new THREE.MeshPhongMaterial( { color: 0xff0000, transparent:true, blending:THREE.NormalBlending, opacity:0.5 } );	//赤
}

  mesh[z][y][x] = new THREE.Mesh( geometry, material );				//メッシュ：形と色を１つにまとめる。

var rad = 3.14159 / 180 * angle;
  mesh[z][y][x].position.set( pos[z][y][x].x, pos[z][y][x].y, pos[z][y][x].z );
if (z == 1 || z == 2 || z == 3) {
  scene.add( mesh[z][y][x] );											//シーンにメッシュを登録（カメラに見える世界に登録）
}
var material2;
material2 = new THREE.LineBasicMaterial({color:0x000000,linewidth:5}) ;
geometry2[index] = new THREE.Geometry();
geometry22[index] = new THREE.Geometry();
var LINE_SIZE = CUBE_SIZE / 2;
HALF=0;
geometry2[index].vertices[0] = new THREE.Vector3(-LINE_SIZE - HALF, -LINE_SIZE - HALF, -LINE_SIZE);
geometry2[index].vertices[1] = new THREE.Vector3(LINE_SIZE - HALF, -LINE_SIZE - HALF,  -LINE_SIZE);
geometry2[index].vertices[2] = new THREE.Vector3(LINE_SIZE - HALF,  LINE_SIZE - HALF,  -LINE_SIZE);
geometry2[index].vertices[3] = new THREE.Vector3(-LINE_SIZE - HALF, LINE_SIZE - HALF,  -LINE_SIZE);
geometry2[index].vertices[4] = new THREE.Vector3(-LINE_SIZE - HALF, -LINE_SIZE - HALF, -LINE_SIZE);
geometry2[index].vertices[5] = new THREE.Vector3(-LINE_SIZE - HALF, -LINE_SIZE - HALF, LINE_SIZE );
geometry2[index].vertices[6] = new THREE.Vector3(LINE_SIZE - HALF,  -LINE_SIZE - HALF, LINE_SIZE );
geometry2[index].vertices[7] = new THREE.Vector3(LINE_SIZE - HALF,   LINE_SIZE - HALF, LINE_SIZE );
geometry2[index].vertices[8] = new THREE.Vector3(-LINE_SIZE - HALF,  LINE_SIZE - HALF, LINE_SIZE );
geometry2[index].vertices[9] = new THREE.Vector3(-LINE_SIZE - HALF,  -LINE_SIZE - HALF,  LINE_SIZE);
geometry2[index].vertices[10] = new THREE.Vector3(LINE_SIZE - HALF,  -LINE_SIZE - HALF,  LINE_SIZE);
geometry2[index].vertices[11] = new THREE.Vector3(LINE_SIZE - HALF,  -LINE_SIZE - HALF,  -LINE_SIZE);
geometry2[index].vertices[12] = new THREE.Vector3(LINE_SIZE - HALF,  -LINE_SIZE - HALF,  LINE_SIZE );
geometry2[index].vertices[13] = new THREE.Vector3(LINE_SIZE - HALF,  LINE_SIZE - HALF,  LINE_SIZE );
geometry2[index].vertices[14] = new THREE.Vector3(LINE_SIZE - HALF,  LINE_SIZE - HALF,  -LINE_SIZE);
geometry2[index].vertices[15] = new THREE.Vector3(LINE_SIZE - HALF,  LINE_SIZE - HALF,  LINE_SIZE );
geometry2[index].vertices[16] = new THREE.Vector3(-LINE_SIZE - HALF,  LINE_SIZE - HALF,  LINE_SIZE);
geometry2[index].vertices[17] = new THREE.Vector3(-LINE_SIZE - HALF,  LINE_SIZE - HALF,  -LINE_SIZE);

for (var i = 0; i < 18; ++i) {
   geometry22[index].vertices[i] = new THREE.Vector3(geometry2[index].vertices[i].x,geometry2[index].vertices[i].y,geometry2[index].vertices[i].z);
}

lines[index] = new THREE.Line(geometry22[index],material2);
lines[index].position.set( pos[z][y][x].x, pos[z][y][x].y, pos[z][y][x].z );
if (z == 1 || z == 2 || z == 3) {
scene.add(lines[index]);
}

} else {
  var index = z * 10 * 10 + y * 10 + x;
  pos[z][y][x] = new THREE.Vector3( CUBE_SIZE * 100, CUBE_SIZE * 100, CUBE_SIZE  * 100);
  var geometry = new THREE.CubeGeometry(CUBE_SIZE, CUBE_SIZE, CUBE_SIZE);
  var material;
  material = new THREE.MeshPhongMaterial( { color: 0x0000ff, transparent:true, blending:THREE.NormalBlending, opacity:0.5 } );	//青
  mesh[z][y][x] = new THREE.Mesh( geometry, material );				//メッシュ：形と色を１つにまとめる。
  mesh[z][y][x].position.set( pos[z][y][x].x, pos[z][y][x].y, pos[z][y][x].z );
}
}
}
}

var textMaterial = new THREE.MeshLambertMaterial( { color: 0x00ff00 } );
for (var i = 0; i <11; ++i) {
if (i == 10) {
textGeometry[i] = new THREE.TextGeometry( ".", {size: 8,height: 4,curveSegments: 3,font: "helvetiker",weight: "bold",style: "normal",bevelThickness: 1,bevelSize: 0,bevelEnabled: true});
}else {
textGeometry[i] = new THREE.TextGeometry( i, {size: 8,height: 4,curveSegments: 3,font: "helvetiker",weight: "bold",style: "normal",bevelThickness: 1,bevelSize: 0,bevelEnabled: true});
}
textNumber[i] = new Array(5);
for (var j = 0; j < 5; ++j) {
textNumber[i][j] = new THREE.Mesh( textGeometry[i], textMaterial );
textNumber[i][j].position.x = j * 5;
scene.add( textNumber[i][j] );
}

}

 
  ( function renderLoop () {
    requestAnimationFrame( renderLoop );							//毎フレーム更新


//x,y,zの位置からインデックスを取得
var x = Math.abs(~~((Math.cos(rad) * ((player_pos.x + CUBE_SIZE * CUBE_NUM / 2) / CUBE_SIZE)) + (Math.sin(rad ) * ((player_pos.y + CUBE_SIZE * CUBE_NUM / 2) / CUBE_SIZE))));
var y = Math.abs(~~((Math.cos(rad) * ((player_pos.y + CUBE_SIZE * CUBE_NUM / 2) / CUBE_SIZE)) - (Math.sin(rad) * ((player_pos.x + CUBE_SIZE * CUBE_NUM / 2) / CUBE_SIZE))));
var z = ~~(((player_pos.z + CUBE_SIZE / 2) / CUBE_SIZE)) + 1;
var add = -1;
if (rad != 0) {x=8-x; add=0;}
//数値を文字へ変換
var ss = "" + y;//(~~((player_pos.y + CUBE_SIZE * CUBE_NUM / 2) / CUBE_SIZE));
var t = 0;
for (var i = 0; i < 1; ++i) {
t = ss.substr(i, 1);
if (t == ".") {textNumber[10][i].position.y = 10;}
else {
 for (var j = 0; j < 10; ++j) {
 if (j == t) { textNumber[t][i].position.y = 10; }
 else {textNumber[j][i].position.y = 0;}
 }
}
}

if (!rotation_flag) {

//重力をspeedに加算
//if (player_pos.y + PLAYER_SIZE / 2> mesh[0][0][0].position.y + CUBE_SIZE) {
  jump_speed -= GRAVITY;
//} else if (player_pos.y + PLAYER_SIZE / 2 < mesh[0][0][0].position.y + CUBE_SIZE) {
//  jump_speed = 0;
//  player_pos.y = mesh[0][0][0].position.y + CUBE_SIZE - PLAYER_SIZE / 2;
//}

var addi=0;
//床の当たり判定
for (var i = -1; i <2; ++i) {
addi = i;
if(rad != 0) {addi = 1; add = i;}
for (var j = -1; j <2; ++j) {
if (
player_pos.x > mesh[z+j][y + add][x+addi].position.x - (CUBE_SIZE + PLAYER_SIZE) / 2 &&
player_pos.x < mesh[z+j][y + add][x+addi].position.x + (CUBE_SIZE + PLAYER_SIZE) / 2 &&
player_pos.y < mesh[z+j][y + add][x+addi].position.y + (CUBE_SIZE + PLAYER_SIZE) / 2 &&
player_pos.y > mesh[z+j][y + add][x+addi].position.y - (CUBE_SIZE + PLAYER_SIZE) / 2 &&
player_pos.z > mesh[z+j][y + add][x+addi].position.z - (CUBE_SIZE + PLAYER_SIZE) / 2 &&
player_pos.z < mesh[z+j][y + add][x+addi].position.z + (CUBE_SIZE + PLAYER_SIZE) / 2
) {
	if (player_pos.y < mesh[z+j][y + add][x+addi].position.y+ (CUBE_SIZE + PLAYER_SIZE) / 2) {
		player_pos.y = mesh[z+j][y + add][x+addi].position.y + (CUBE_SIZE + PLAYER_SIZE) / 2;
		jump_speed = 0;
	}
}
}
}
//当たり判定
if (x_speed < 0) {x_left(x, y, z);}
if (x_speed > 0) {x_right(x, y, z);}
if (jump_speed > 0) {y_top(x, y, z);}
if (z_speed > 0) {z_back(x, y, z);}
if (z_speed < 0) {z_front(x, y, z);}

//if (player_pos.x < -3 * CUBE_SIZE - PLAYER_SIZE / 2 + 1) {x_speed = 0; player_pos.x = -3 * CUBE_SIZE - PLAYER_SIZE / 2 + 1;}
//if (player_pos.x > 3 * CUBE_SIZE + PLAYER_SIZE / 2 - 1) {x_speed = 0; player_pos.x = 3 * CUBE_SIZE + PLAYER_SIZE / 2 - 1;}
//if (player_pos.y < -3 * CUBE_SIZE - PLAYER_SIZE / 2 + 1) {jump_speed = 0; player_pos.y = -3 * CUBE_SIZE - PLAYER_SIZE / 2  + 1;}
if (player_pos.z < mesh[0][1][0].position.z  + (CUBE_SIZE + PLAYER_SIZE) / 2) { z_speed = 0; player_pos.z = mesh[0][1][0].position.z  + (CUBE_SIZE + PLAYER_SIZE) / 2}
if (player_pos.z > mesh[4][1][0].position.z  - (CUBE_SIZE + PLAYER_SIZE) / 2) { z_speed = 0; player_pos.z = mesh[4][1][0].position.z  - (CUBE_SIZE + PLAYER_SIZE) / 2}

//位置にspeedを追加
player_pos.x +=       x_speed;
player_pos.y += jump_speed;
player_pos.z +=       z_speed;

}//rotation_flag

//ボタンが押されていたらspeedに速さを入れる
    if (keyArray[0] ) {        keyArray[0] = false;        x_speed = -0.5;}
    if (keyArray[2] ) {        keyArray[2] = false;        x_speed =  0.5;}
    if (keyArray[1] ) {        keyArray[1] = false;        z_speed = -0.5;}
    if (keyArray[3] ) {        keyArray[3] = false;        z_speed =  0.5;}
    if (keyArray[4]  && jump_speed == 0) {        keyArray[4] = false;        jump_speed = JUMP_SPEED;    }
    if (keyArray[5] ) { keyArray[5] = false; rotation_flag = !rotation_flag;} 
    if (keyArrayUp[0]) {        keyArrayUp[0] = false;   x_speed = 0; }
    if (keyArrayUp[2]) {        keyArrayUp[2] = false;   x_speed = 0; }
    if (keyArrayUp[1]) {        keyArrayUp[1] = false;   z_speed = 0; }
    if (keyArrayUp[3]) {        keyArrayUp[3] = false;   z_speed = 0; }


//位置をプレイヤー位置に設定
    player.position.set(player_pos.x, player_pos.y,player_pos.z	);

//回転角を代入
if (rotation_flag) { angle += 1;}
if (angle % 90 == 0) { rotation_flag = false; }
rad = 3.14159 / 180 * angle;
for (var z = 0; z < Z_NUM; ++z) {
for (var y = 0; y < CUBE_NUM; ++y){ 
for (var x = 0; x < CUBE_NUM; ++x) {
//枠の位置のキューブなら回転する
if (x == 0 || x == CUBE_NUM - 1|| y == 0 || y == CUBE_NUM -1 ||
x % 2 ==  0 &&  y % 2 == 0 && z % 2 == 1 //||
//x % 2 == 1 && y % 2 == 1 && z % 2 == 0
) {
  var i = z * 10 * 10 + y * 10 + x;
  mesh[z][y][x].position.set( Math.cos(rad) * pos[z][y][x].x + Math.sin(rad) * pos[z][y][x].y, Math.cos(rad) * pos[z][y][x].y - Math.sin(rad) * pos[z][y][x].x, pos[z][y][x].z );
  lines[i].position.set( Math.cos(rad) * pos[z][y][x].x + Math.sin(rad) * pos[z][y][x].y, Math.cos(rad) * pos[z][y][x].y - Math.sin(rad) * pos[z][y][x].x, pos[z][y][x].z );
}
}
}
}
    renderer.render( scene, camera );								//レンダラーにシーンとカメラを登録
  } )();
};
 
window.addEventListener( 'DOMContentLoaded', main, false );		//イベント登録
</script>
 
</body>
</html>